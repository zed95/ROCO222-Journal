2 - Build a DC motor (02/10/2017)
==================================

## Building the commutator
 
The **commutator** is responsible for reversing the current through the coil when that coil moves through the magnetic field to ensure constant rotation of the motor. A basic commutator is simply two metal plates which will come in contact with positive and negative wires of the power supply while rotationg.
 
The first step me and my lab partner Kyle have taken to contruct the commutator was sticking the copper tape around one side the cork.
 
![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/IMG_0486.JPG)
 
Before dividing the copper into two plates, I have decided to first draw a line on the cork to indiciate where we should make the divide. The point of this was to make sure that the lengths of the two plates are approximately the same length.
 
![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/IMG_0487.JPG)
 
![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/IMG_0488.JPG)


## Adding the support shaft
 
The support shaft is usually a metal rod on which the **armature** rests on and spins around its axis. The support shaft we will be using is made up if two metal pins.
 
There wasn't much to do in this section, the two pins only needed to be pushed into the middle of the cork from both sides create the shaft.
 
![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/IMG_0489.JPG)

## Winding the armature coil
 
The **armature coil** generates a megnetic field when current is passed through it. Combined with magnets, attractive and repulsive forces are generated which make the coil rotate. The coil is created by winding the copper wire around an object.
 
Before me and Kyle started winding the copper wire around the cork, we made sure that one end of the wire is sticking out so that it can then be attached to one of the sides of the commutator to allow current to pass through the coil.
 
Winding the wire around the cork wasn't easy as the copper wire kept getting tangled, which then had to be untangled which in turn took time and effort. In addition to that, we had to be careful to not damage the commutator in any way. After achieving **150 turns** of wire around the cork, we have sucuessfully created the coil. We have measured the total resistance of the coil using a multimeter; the measured value was **7.5&#937;**. We made sure that there was enough wire to attach the other end to the other part of the commutator.To secure the coil, we have taped it to the cork using electrical tape. The two ends of the wire had to be sanded down to remove the enamel on the copper which prevented the it wire from conducting electricity. At the end, I soldered the wires to the commutator.
 
![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/IMG_0491.JPG)
 
![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/IMG_0492.JPG)


## Building magnet brackets and shaft support
 
The **shaft support** is where the shaft is going to rest. The purpose of the shaft support is to susped the armature with the coil in the air so that nothing stops it from spinning.The purpose of the magnet is to provide a magnetic field for the motor's magnetic field to interact with and produce torque. We have been provided with large paperclips to produce the shaft support and magnet brackets.
 
To create the shaft support we have taken two steps. The first step was to bend the paperclip so that it formed a 90&#176; bracket. The second step was to bend the vertical end of the paperclip out and then create a loop for the shaft to fit in. To create the magnet brackets we just followed the first step.


## Building the baseplate
 
We have been provided with a baseplate, screws and washers to attach everything onto the baseplate. We have marked the baseplate wih two lines perpendicular to each other so that we could align the parts correctly. We have then aligned the paperclips and attached them to the baseplate using the screws and washers. Next, we have placed the DC motor on the shaft support and then atached the neodymium magnets onto the magnet brackets, at the same height as the coil. The magnets came together several times during this process and due to neodymium magnet strength, trying to separate them became bothersome. We have learned that we should be more careful when handling neodymium mangnets.
 
![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/IMG_0493.JPG)


## Finishing the motor
 
Once me and Kyle attached everything to the baseplate, We created brushes from copper wire. The brushes supply power to the coil so that it can produce torque. We have connected supply leads to the copper wires and adjusted the voltage to 12V and set the current limit to 2A as advised.
 
![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/IMG_0494.JPG)


 ## Testing the motor
 
After switching on the supply, the coil twitched, but did not rotate. I suspect that it was due to the fact that the commutator was not smooth and circular enough in shape to continously conduct current well. I did not have enough time to improve the shape of the commutator and test it and so that will be the first thing I do during the next practical.


2 - Build a DC motor (09/10/2017)
==================================

 ## Testing the motor
 
 As suspected last week, The problem with the motor twitching but not actually rotating was the commutator shape. The commutator needed to be more round (it became deformed when winding the wire to create the coil). After forming the commutator to have a more round shape, the motor started spinning without any problems.
 
 To make sure that the connection is constant between the coil and the power supply during the spinning of the motor, I have folded the bursh wires. I have done this because during the motor operation the brushes moved and sometimes lost contact with the crocodile clips of the power supply. 
 
![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/Improved%20Commutator%20shape.JPG)
 
![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/Folded%20brush%20wires.JPG)


2 - Build a DC motor (10/10/2017)
=================================

 ## Testing the motor
 
**Measure rotational speed using modulation in armature current**
Measuring the rotational speed is based on the fact that the faster the motor rotates the more current it draws. 
 
**How fast does the motor rotate at a given applied voltage**

Assuming that the motor is unloaded, the equation for the torque is given by: **&#964; = d&#215;B&#215;I&#215;L** Since I know that the motor will draw more current as it rotates and the current is limited by the voltage and resistance, substituting I = V/R means that the motor will rotate faster by increasing the voltage and/or decreasing resistance.

2 - Build a DC motor (12/10/2017)
=================================

 ## A better DC motor

 I have originally decided that I am going to make a 6 coil motor with some iron inside the armature to increase the magnetic field strength. After ordering iron washers, I realised that the armature would have to be much larger to accomodate the washers in all 6 of the armature teeth, since the washers were 3/4" in outer diameter. To keep the armature approximately the same size as the one I designed previously designed, I decided to stick with 3 coils. Having only 3 coils in the design made the design only a little bigger, with the original design having dimensions of 50x50x75mm and the new design having dimensions of 68x68x75mm to accommodate the iron washers. The new design is based on the old design of the armature which I created several months ago as a part of my personal project. Because I will have iron washers inside of my coils, the DC motor will be subject to **cogging**. To reduce the effects of cogging I have rotated the armature teeth by 6&#176;.
 
![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/Old%20Armature.png)
A picture of the old armature design
 
[For 3D view of new armature design click here](https://github.com/zed95/ROCO222-Journal/blob/master/3Dprints/ROCO222%20Armature.stl)
A picture of the new armature design
 
When the new armature finished printing, I placed the iron washers inside the armature teeth. I managed to fit 20 washers in each tooth which added weight to the print. To make sure that they do not fall out (I had to make the holes bigger than the washers actually are to make up for the fact that 3D printers are not 100% accurate and might not print the desired hole size), I used tape the secure them in place.
 
 My next step was to start winding the copper wire around the armature teeth to create coils. I wanted to have 1000 turns on each but settled at 800 turns on each tooth as the coils would become too big to fit around the armature. I kept a tally so that I don't forget how many turns I have done on a particular tooth. I would add one to the tally every 100 turns. To make sure that the coil does not unwind during the winding process, I applied super glue every 300 turns and after finishing winding a tooth. The DC motor is wave wound. The reason for having so many turns of wire on each coil is to increase the torque generated when the motor is powered. The equation for torque  **&#964; = d&#215;B&#215;I&#215;L** (Assuming that &#920; = 0)  states that the force will increase by increasing the width of the coil (d) or the magnetic flux density (B) or the current (I) or the length of the wire (L) in the magnetic field. By having so many turns on each coil, I am esentially increasing the length of wire in the magnetic field.

![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/New%20armature%20showing%20washers.JPG)
A picture of the new armature design with the washers fitted.
 
![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/New%20armature%20with%20coils.JPG)
A picture of the new armature with coil windings.
 
![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/Turns%20tally.png)
A picture of the turns tally.
 
I have also attached a shaft to the armature (as seen in the picture above) to allow the DC motor to spin when it is powered. The shaft is longer on one side and shorter on the other, the reason being that I will have to attach an encoder on the longer side of the shaft.


2 - Build a DC motor (16/10/2017)
==================================

## A better DC motor

Today I added copper to the commutator and soldered the wires of the coils onto it. I then tested the DC motor to see how it performs. The magnetic field was very strong compared to the previous DC motor me and Kyle made, however, it was difficult to start the motor due to the support not being able to hold motor and the magnet holders not being able to hold the strong neodymium magnets in place.
 
 Upon arriving home, I began to design the new, improved motor support and magnet holders. I designed DC motor support to be triangular in shape so that if the motor starts vibrating the whole structure is more stable overall. intending to screw the support into the wood, I made holes for the screws in the support. The benefit of doing it this way over glueing the support to the wood is that I can always unscrew the support and adjust it if it needs re-aligning.
 
 To save on the cost of printing the DC motor support, I changed the shape of the supoport by removing sections of the support that are unnecessary. Removing the unecessary parts left the support looking like a trapezium and reduced the cost by £1.74 per support.
 
[For 3D view of motor support click here](https://github.com/zed95/ROCO222-Journal/blob/master/3Dprints/Shaft%20support.stl)
 
 After finishing the motor support design, I moved onto the magnet holders design. Designing the holders was more complicated compared to the motor support because I needed to make sure that the magnets will be in line with motor. I drew a diagram to help me with working out how high the magnet holders need to be and where the magnets needs to be positioned to be in level with the motor. I have made the thickness of the holders 10mm so that they are durable. Originally, I made openings at the back so that the magnets could be inserted into the holders but changed my mind and re-designed the holders to have the openings for the magnets on top; this way they are less likely to fall out of the holders. I have also made holes for screws in the magnet holders for the same reason mentioned in designing the motor support. Similarly, I also removed unnecessary material from the magnet holders to reduce the cost of printing and saved £2 per magnet holder.
 
![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/Magnet%20holder%20dimenions.png)
 A picture of the diagram used to work out the required height of the magnet holders.
 
[For 3D view of magnet holder click here](https://github.com/zed95/ROCO222-Journal/blob/master/3Dprints/Magnet%20holders.stl)

I have designed the holders to hold the two magnets separately because I wanted the magnetic flux to cut through a larger portion of the coils of the motor to increase the force produced according to the equation **F = BIL**. The distance between the magnets and the motor is also very important. Since the force between any pair of magnets decreases with distance, I will place the magnets as close to the motor as possible so that the force produced is as high as possible when the motor is running.

![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/Motor_magnet%20distance.jpeg)
The distance between the magnets and the coils is small.

![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/Motor%20without%20brushes.jpeg)
How the motor looks so far.

**Brushes design**
The Brushes consist of four parts, The moving part of the brush, the brush mount, a spring and the wire. The the spring is placed inside the brush mount together with the brush to allow the brush to adjust itself to the commutator. The commutator is not perfectly round and so the spring makes sure that there is contact that does not stop the motor from rotating. The height of the brush mount has similar dimensions to the height of the magnet holder as the brushes need to be in level with the commutator and since the magnets were measured to be in line with the commutator I just made sure that the hole of the brush mount was placed at the same height.

Picture of completed brush: ![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/Motor%20without%20brushes.jpeg) 

The actual brushes are designed to fit into the holes and have a larger round ending so when the brush is being pushed back by the commutator, it doesnt damage the commutator and vice versa. The reason why I made the end bigger is so that the brush never fully enters the brush mount. I glued wire (0.6mm diameter) onto the tip of the brsushes to provide power to the motor. I previously used aluminium from a can but it didn't work very well as no solder wanted to stick to it and it was too thin (0.2mm) and so it wore away really quickly and was too bendy. Additionally the aluminium had to be cut out and then glued to the commutaro which took time; the wire was much easier to work with and lasts longer. The wire on the brushes is prependicular relatvie to the wire on the commutator so that the two do not get stuck and break when the motor is rotating.

The completed motor: ![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/Completed%20motor.jpeg) 

![](https://github.com/zed95/ROCO222-Journal/blob/master/Images/Motor%20rotating.gif)


##Cons in my design and possible improvements

**Overall torque**

The possible improvements I could make to the motor is add more coils to improve the operation of the motor. Adding more coils would make the output torque more constanct (smooth) as the motor rotates. The reason why the torque on my motor is not constant is because the torque equation mentioned earlier says that the torque is also determined by the angle (cos&#920;) of the coil relative to the magnetic field. Maximum torque is experienced at cos&#920; = 0 and zero at cos&#920; = 90. Therefore the more more coils there are the higher the minimum torque. The diagram below shows the overall torque compared to the number of coils the motor has. The more area is enclosed in the curves the more overall torque the motor has.

![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/Torque%20vs%20angle.png)

**Centre of mass**

The centre of mass of the motor is not located in on the axis of rotation (on the shaft) which introduces vibrations when the motor attempts to spin faster.  

**The commutator**

I would say that the biggest con of my motor is the commutator. Even though I have improved it, it is not to the standard I would like it to be. Because the commutator is a few rows of wire with spaces between them, the brushes and the commutator will not be contact all the time while the motor is rotating whcih will affect the torque of the motor. Furthermore, there is a lot friction between the commutator and the brushes which significantly reduces the speed of my motor. What I would differently next time is attach copper plates to the commutator instead of wires or aluminium strips cut out from a can; this way the durability of the commutator would improve, the contact with the brushes would be better and soldering the coil wires to the commutator would be much easier as trying to solder copper to the aluminium proved to be horribly hard and required me to actually glue the wire to the aluminium. I would also try to reduce the friction between the brushes and the commutator so the speed losses are reduced.


**Calculating theoretical torque of my motor**
* The equation for torque is: 	**&#964; = d&#215;B&#215;I&#215;L&#215;cos&#952;**
* I will assume that the coil is perpendicular to the magnetic field and therefore cos(0) = 1: **&#964; = d&#215;B&#215;I&#215;L**
* I have measured the resistance of each of the three coils and got that the average resistance of the three is: **33&#937;**
* I am using 30V to power my motor and so the current that will flow through the coil is given by ohms law: **I = V/R = 30/33 = 0.91A**
* The length of the wire of the coil on the outside of the coil was measured to be approximately 5cm = 0.05m. since the length is not the same everywhere in the coil I will assume that the average length of each turn of wire is **4cm = 0.04m**. Since there is 800 turns in each coil the total length of the wire in the magnetic field is 800 * 0.08 = 32m. There is 64 meters of wire in the magnetic field.
* The average radius from the centre of the coil was measured to be **2cm = 0.02m**. Since there are two sides of the coil then multiply this value by 2 to get accurate representation of the torque. so **d = 0.04m.**
* I have used this [website](https://magnet.com.au/magnet-strength-flux-calculator.html) to calculate the magnetic flux density, B (in Tesla). The airgap between the neodymium magnet and the coil is 17mm, the magnet length is 5mm  and the diameter is 20.2mm. The value I got from the calculator is **0.032 Tesla**. Multiply this value by 4 since there are 4 magnets and I get a value of **0.128 Tesla**

Plugging all those numbers into the equation I get that the torque, &#964; produced will be **0.149Nm**

3 - Incremental encoder (16/10/2017)
======================================

## Building the incremental encoder
 
The phototransistor switches on when the IR light shines onto it.
 
We have been provided with a circuit diagram according to which we must construct the encoder. Making the IR light source and the light detector wasnt hard, we just needed to solder the two onto the verboard. We have then moved onto testing the circuit. While testing I realised that I soldered the positive pin of the phototransistor to the negative pin of the LED and I wasnt getting any results. After I corrected the mistake, I tested the circuit again and everything was working as intended; we had a voltage drop when we covered the LED so that the IR light didnt reach the phototransistor and we could see the IR light from the LED when we took a photo using the phone.
 
![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/Encoder%20circuit%20diagram.png)
Picture of the encoder circuit provided.
 
![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/original%20circuit.jpeg)
A picture of our encoder circuit.
 
![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/IR%20light.jpg)
Picture of the IR light being emitted.
 
![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/IR.jpeg)
A picture of voltage level when the IR light is allowed to shine onto the phototransistor.

![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/IRblocked.jpeg)
A picture of the voltage level when the IR lights is blocked from the phototransistor.
 
While testing we have been told that we will need the LED and phototransistor to be higher up relative to the verobard so that the rotating disc that we will use to block the IR light can block the light properly; otherwise the voltage drop may not be significant enough and our encoder will not work as intended. I will make the necessary adjustments with Kyle in the next practical.

3 - Incremental encoder (23/10/2017)
==========================================================
How the encoder works:

The encoder has 3 main parts: Phototransistor, Light source and encoder disc.
As the motor rotates the light to the phototranasitor is blocked and pulses are creatd. The number of pulses per second determines the rotational speed of the motor. The resolution of the encoder can be increase by intorducing more holes to the encoder disc. the pulses will then represent a smaller angle change, for example having one hole will only allow a person to measure revolutions per second but having two holes will allow one to measure the time it takes for the for half a revolution. Having 360 holes will allow one to measure angular velocity with a resolution of 1 degree. If there are two sensors with some distance apart, the direction of rotation can also be deduced. This is because there will be a phase shift between the pulses of the two which can give away the direction of rotation. If one sensor is placed at 12 o'clock and one at 3 o'clock and the phase between the two pulses of the sensors are measured and sensor at 12 o'clock leads in phase the motor is rotating clockwise; if the sensor at 3 o'clock leads in phase then the motor is rotating anti-clockwise.

![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/Encoder%20phase.jpg)

We have made the necessary adjustments to the positioning of our components on the breadboard and our circuit was ready to be used. After adding the encoder disc, we were ready to estimante the speed of rotation of our motor.

![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/Adjusted%20circuit.jpeg)
A picture of the adjusted encoder circuit.

![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/Encoder%20disc.jpeg)
A picture of the encoder disc

## Estimating rotation speed in RPM
How it works is we should get a square wave as the motor rotates because the disc allows the light to reach the phototransistor and then blocks the IR light so it doesnt get to the transistor. When the light shines onto the phototransistor the voltage goes to 5V and when it is blocked it goes to 0V and so a square wave between 0V and 5V will be produced at a frequency which is determined by the speed of rotation the motor. Obtaining the frequency will allow me and kyle to calculate speed of rotation. Frequency is measured per second and each cycle corresponds to one revolution then multiplying the frequency by 60 we should get rotations per minute.

Oscilloscope reading: ![](https://github.com/zed95/ROCO222-Journal/blob/master/Images/MeasuringRPM.gif)

THe average frequency read from the oscilloscope was about 20Hz. 20Hz corresponds to 20 revolutions per second; if I multiply this value by 60 I get that my motor rotates at 1,200 revolutions per minute. I believe that the motor can go faster than that but due to the commutator being worn out and not having the brushes designed yet, caused the motor to not spin at the maximum velocity it could potentially rotate at. One thing I also noticed is that the readings ocasionally jumped to over 100Hz. The reason for it might be that the design of the encoder disc, the circuit and other parts is very crude and might be susceptible to some errors.


## Calculating Angular velocity of the motor
Me and kyle have written the code to display the pulse count on the serial monitor in the Arduino IDE. After uploading the program to the arduino we have decided to see if we can calculate the angular velocity of our motor. The code is shown below.

```C
const byte ledPin = 13;
const byte interruptPin = 2;
volatile byte state = LOW;
unsigned int PulseCounter = 0;                                                  //Store the pulse count here
unsigned int TimePoint1 = 0, TimePoint2 = 0;                                    //Time at the start of the loop will be stored in TimePoint1 and time at the end of the loop will be stored in TimePoint2





void AngularVelocity() {                                                      // Right now I assume that I have one hole which calculates me the revolutions per second but we will do calculations for getting the angular velocity
TimePoint1 = millis();                                                        //Store current time since begninning of the program
  Serial.println(PulseCounter);                                               //Display the pulse count on the serial monitor
  PulseCounter = 0;                                                           //Reset the pulse counter
}



void setup() {
 Serial.begin(9600);                                                            //Initialise serial communication at 9600 bits per second
pinMode(ledPin, OUTPUT);
pinMode(interruptPin, INPUT);
// configure the interrupt call-back: blink is called everytime the pin
// goes from low to high.
attachInterrupt(digitalPinToInterrupt(interruptPin), blink, RISING);
TimePoint1 = millis();                                                        //Store current time since begninning of the program
}
void loop() {
digitalWrite(ledPin, state);
TimePoint2 = millis();                                                        //Store current time since begninning of the program

if(TimePoint2 - TimePoint1 >= 1000) {                                         //If the difference between the two time points is more or equal to 1000ms (1 second)
    AngularVelocity();                                                        //Run the Angular velocity function
}
}
void blink() {
state = !state;
PulseCounter ++;                                                            //Increment the counter
}
```

Result:
![](https://github.com/zed95/ROCO222-Journal/blob/master/Images/Encoder.gif)

Afer having several attempts we have come to the conclusion that something is going wrong in recording the angular velocity of our motor. We have plotted graphs with our results and the readings were looking very inconsistent and some of them even ridiculous like 1000 revolutions per second which would correspond to a angular velocity of 360,000 degrees per second. For comparison, We have measured the angular of my drill; although the recordings varied less than in our motor, the results were still slightly inconsistent with the velocity being 14,400 degrees per second on average and then suddenly rocketing to around 28,800 or diving to around 3,600 in matter of a second bearing in mind that the drill has a profesionally designed motor compared to our crude design. Because of this my conclusion for today is that the problem lies somewhere in the encoder disc or the circuit. I will look into it tomorrow and try to figure out what the problem is.

![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/Angular%20v%20A1.png)
A picture of angular velocity graph of the motor x-axis = time in seconds and y-axis is pulses per second.

![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/Angular%20v%20A2.png)
A picture of angular velocity graph of the motor x-axis = time in seconds and y-axis is pulses per second.

![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/Angular%20v%20A3.png)
A picture of angular velocity graph of the motor x-axis = time in seconds and y-axis is pulses per second.

![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/Drill%20angular%20velocity%20readings.png)
A picture of angular velocity graph of the drill. x-axis = time in seconds and y-axis is pulses per second.
 
3 - Incremental encoder (24/10/2017)
==========================================================

## Calculating Angular velocity of the motor

After some investigation we have found the cause of the absurdly large encoder readings we have been getting when trying to measure the angular velocity of the motor and I can go on to say that my conclusion from yesterday is wrong. The cause of these anomalous readings is the magnetic field that our motor produces when we it is rotating. How we found that the circuit reacts to the magnetic field is we did not use the encoder disc to block out the IR light. If there is nothing to block out the light the encoder should not display any pulses being recorded. We have powered the motor and placed the encoder where we usually placed it when we tried to record the angular velocity and the encoder acted as if the encoder disc was blocking the light and displayed a random pulse count numbers on the serial monitor. This is why the readings me and Kyle took yesterday seemed incorrect and indeed were. The magnetic field was also the reason for ocassional jumps in frequency when recording the RPM of the motor using the oscilloscope. Furthermore this explains why the recorded values for the drill were slightly more consistent than the recorded values for our motor. Because of this we were not able to record the angular velocity of our motor properly. The only way we will be able to record the readings is to extend the shaft of the motor to increase the distance between the encoder circuit and the magnetic field or/and reduce the voltage and current to the motor so that the magnetic field is weaker and does not interfere with the encoder circuit.

the anomalous readings from the encoder: ![](https://github.com/zed95/ROCO222-Journal/blob/master/Images/Encoder%20and%20Motor.gif) 

3 - Incremental encoder (26/10/2017)
==========================================================
I have changed the encoder circuit and used a lser diode along with a different phototransistor to see if the angular velocity readings would settle and give a reasonable value for the angular velocity. The circuit is identical but the two components have changed. To my dissapointment, even with the phototransistor significant distance apart from the motor, the result was the same. I wanted to try to reduce the voltage to see if this would help but the friction between the brushes and the commutator was too great for the motor to start. I am dissapointed that I cannot measure the speed of the motor as I wanted to see if this design was an improvement from the one I made before.

![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/Laser%20and%20phototransistor.jpeg)

## Improving the resolution of the encoder
what I can do to improve the resolution of my encoder is instead of measuring the pulses per second I can measure the time difference between the pulses to get the angular velocity. How this would work is I would record time for one pulse and then the time for the other pulse. I would then subtract pulse time one from pulse time to to get the time difference between the two. I know that a time difference of 1 second would correspond to one revolution per second (or 360 degrees per second). Similarly, a time difference of 2 seconds would correspond to a angular velocity of 180 degrees per second since it took two seconds for a full revolution. Again, if the time between the pulses is 500ms, this would correspond to angular velocity of 720 degrees per second since a full revolution took only half a second.

If I have time I will update the code to do just that.



4 - Motor control with Arduino (06/11/2017)
============================================

## Control a hobby DC motor

The first part of the lab was setting up the arduino and the arduino motor shield and was very easy to do.

![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/Motor%20shield.jpeg)
A picture of the motor shield connected on top of the Arduino board

After connecting the a DC motor to the shield correctly and uploading the code, the DC motor rotated forward quicker than it rotated backwards.

![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/Motor%20connected.jpeg)
A picture of the DC motor connected to the motor shield

```C
/*************************************************************
Motor Shield 1-Channel DC Motor
by Randy Sarafan
For more information see:
https://www.instructables.com/id/Arduino-Motor-Shield-Tutorial/
*************************************************************/
void setup() {
//Setup Channel A
pinMode(12, OUTPUT); //Initiates Motor Channel A pin
pinMode(9, OUTPUT); //Initiates Brake Channel A pin
}
void loop(){
//forward @ full speed
digitalWrite(12, HIGH); //Establishes forward direction of Channel A
digitalWrite(9, LOW);
//Disengage the Brake for Channel A
analogWrite(3, 255);
//Spins the motor on Channel A at full speed

delay(3000);

digitalWrite(9, HIGH); //Eengage the Brake for Channel A

delay(1000);

//backward @ half speed
digitalWrite(12, LOW); //Establishes backward direction of Channel A
digitalWrite(9, LOW);
//Disengage the Brake for Channel A
analogWrite(3, 123);
//Spins the motor on Channel A at half speed

delay(3000);

digitalWrite(9, HIGH); //Eengage the Brake for Channel A

delay(1000);

}
```

## Controlling my DC motor in closed-loop

What I decided to do first is write the code that will provide me with the feedback I need to control the speed of my motor. I have written a set of points that describe what my code is supposed to be doing. Doing this helps me get a better idea of what code I need to write and how I need to write it.

* The output PWM of the motor shield is 0 at the start.
* When I set the desired speed in RPM, the program will start increasing the output PWM and compare the speed of motor with desired speed.
* When speed is still too low the PWM will be increased.
* When speed goes over desired value the PWM will be decreased.
* The PWM will be increased gradually from zero in small increment values.

The finished program:

```C
const byte ledPin = 13;
const byte interruptPin = 2;
volatile byte state = LOW;
unsigned int PulseCounter = 0;                                                  //Store the pulse count here
unsigned int TimePoint1 = 0, TimePoint2 = 0;                                    //Time at the start of the loop will be stored in TimePoint1 and time at the end of the loop will be stored in TimePoint2
unsigned const int Desired_RPM = 600;                                           //The desired RPM value whicht the speed of the motor will be compared to
unsigned char PWM_value = 0;                                                    //the updated PWM values will be saved here


void Motor_PWM_update(unsigned char updated_PWM)
{
  //forward @ full speed
  digitalWrite(12, HIGH);                                                       //Establishes forward direction of Channel A
  digitalWrite(9, LOW);                                                         //Disengage the Brake for Channel A
  analogWrite(3, updated_PWM);                                                  //spin the motor at new PWM
  
}

void Adjust_PWM(unsigned int Current_RPM)
{
  Current_RPM *= 60;                                                           //Multiply the pulses by 60 to get RPM
  if(Current_RPM != Desired_RPM)                                               //If the current speed of motor does not match the desired speed:
    {
      if(Current_RPM < Desired_RPM)                                            //If the speed is less than the desired speed, increase the duty cycle of PWM signal
         {
          PWM_value++;
         }
     if(Current_RPM > Desired_RPM)                                             //If the the speed is more than the desired speed, decrease the duty cycle of PWM signal
        {
          PWM_value--;
       }
    }
    
    Motor_PWM_update(PWM_value);                                              //Send the new PWM signal to the motor shield
}


void AngularVelocity() {                                                      // Right now I assume that I have one hole which calculates me the revolutions per second but we will do calculations for getting the angular velocity
TimePoint1 = millis();                                                        //Store current time since begninning of the program
  Serial.println(PulseCounter);                                               //Display the pulse count on the serial monitor
  PulseCounter = 0;                                                           //Reset the pulse counter
}



void setup() {

//Setup Channel A of the motor shield
pinMode(12, OUTPUT);                                                            //Initiates Motor Channel A pin
pinMode(9, OUTPUT);                                                             //Initiates Brake Channel A pin

Serial.begin(9600);                                                            //Initialise serial communication at 9600 bits per second
pinMode(ledPin, OUTPUT);
pinMode(interruptPin, INPUT);
// configure the interrupt call-back: blink is called everytime the pin
// goes from low to high.
attachInterrupt(digitalPinToInterrupt(interruptPin), blink, RISING);        
TimePoint1 = millis();                                                        //Store current time since begninning of the program
}

void loop() {
digitalWrite(ledPin, state);
TimePoint2 = millis();                                                        //Store current time since begninning of the program

if(TimePoint2 - TimePoint1 >= 1000) {                                         //If the difference between the two time points is more or equal to 1000ms (1 second)
    AngularVelocity();                                                        //Run the Angular velocity function
    Adjust_PWM(PulseCounter);
}


}
void blink() {
state = !state;
PulseCounter ++;                                                            //Increment the counter every time interrupt is generated
}
```

After connecting the shield to the power supply at 12V and 2A and connecting my DC motor to terminal A of the motor shield, the code was uploaded to the arduino. The result was that the motor did not want to rotate at 12V because of the friction between the commutator and the brushes so I did not manage to actually see whether the speed of my motor is being controlled by the program. 

I have used another motor to see if the code is working. It did work but it was slow due to the fact that the RPM is being compared every second which means to get up to the speed that was set takes a significant amount of time. This is what I would like to improve next time.


5 - Stepper motors (13/11/2017)
============================================

## Wiring the stepper motor

We have connected the stepper motor according to figure 5 in the stepper motor lab sheet. Connecting the stepper motor this way make the stepper motor behave as a bipolar stepper motor.

![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/stepper_motor_diagram.jpg)
Diagram of wiring of stepper motor to the motor shield

![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/Stepper%20motor%20pic.jpeg)
Picture of the wired stepper motor to the motor shield

## Initial program to control the stepper motor

The bipolar stepper motor has both a permanent magnet and a rotor with teeth which align themselves with the magnetic field generated by the coils. The motor is designed in such a way that the teeth of the rotor are only aligned with one group of stator windings at a time. This ensures that the stepper motor will keep rotating when the other stator coils are energised. The step of the motor is determined by the number of the teeth on the rotor, the more teeth there are the smaller the step that can be achieved. The number of rotor teeth can be found by dividing 90 **degrees** by the step of the motor. If I divide 90 by 1.8 which is the step of the motor we are using in the lab I get that the number of teeth on the rotor is 50.

In the code I will need to switch the coils on and off to allow the motor to rotate. Because the rotor is also a magnet I will need to change the polarity once the poles are aligned so that the motor can continue rotating.

the finished code:
```C
#define DIR_A 12
#define PWM_A 3
#define DIR_B 13
#define PWM_B 11

const int delayMs = 5;              //speed control

//control direction of rotation with these two variables
unsigned char PWM_1 = 0;
unsigned char PWM_2 = 255;


//the mode of rotation is also the full step mode

void setup() {
  // put your setup code here, to run once:
pinMode(DIR_A, OUTPUT);
pinMode(DIR_B, OUTPUT);
pinMode(9, OUTPUT); digitalWrite(8, LOW);           //No braking ch. A
pinMode(8, OUTPUT); digitalWrite(8, LOW);           //No braking ch. B
}

void loop() {
  // put your main code here, to run repeatedly:

    digitalWrite(DIR_B, LOW);                  // Ch. B forward      Set the polarity of coils in B
    digitalWrite(DIR_A, LOW);                  // Ch. A forward      Set the polarity of coils in A 

    analogWrite(PWM_A,PWM_1);                  // Ch. A on           Turn on coil pair A to rotate the motor until teeth are aligned with coil pair A
    analogWrite(PWM_B,PWM_2);                  // Ch. B off          Turn off coil pair B to allow the teeth to align with A

    delay(delayMs);                            //rotational speed is controlled by the delay

    analogWrite(PWM_A,PWM_2);                  // Ch. A off          Turn off coil pair A to allow the teeth to align with B
    analogWrite(PWM_B,PWM_1);                  // Ch. B on           Turn on coil pair B to rotate the motor until teeth are aligned with coil pair B


    
    delay(delayMs);


   digitalWrite(DIR_B, HIGH);             // Ch. B backwards    Reverse the polarity in Coils B to allow the stepper motor to spin 
   digitalWrite(DIR_A, HIGH);             // Ch. A backwards    Reverse the polarity in Coils A to allow the stepper motor to spin 

   analogWrite(PWM_A,PWM_1);              // Ch. A on           Turn on coil pair A to rotate the motor until teeth are aligned with coil pair A
    analogWrite(PWM_B,PWM_2);                 // Ch. B off          Turn off coil pair B to allow the teeth to align with A

    delay(delayMs);

   analogWrite(PWM_A,PWM_2);              // Ch. A off          Turn off coil pair A to allow the teeth to align with B
    analogWrite(PWM_B,PWM_1);             // Ch. B on           Turn on coil pair B to rotate the motor until teeth are aligned with coil pair B
    
    delay(delayMs);
}
```

The motor started rotating after this program was uploaded: ![](https://github.com/zed95/ROCO222-Journal/blob/master/Images/Stepper%20motor.gif)

## Programming of modes

We had to program the motor to run in 4 different modes:
* Full-step
* Double-step
* Half-step
* Micro-step

I have actually written the initial code to run the stepper motor in full-step mode, now I have to write the code for the other three. I will now write the code for the other three modes. The diagrams below show how the motor is running in the corresponding first three modes. The black dots represent that the coil has been energised with a specific polarity.

Full-step (code is shown above): ![](https://github.com/zed95/ROCO222-Journal/blob/master/Images/Full%20step.gif)


Double-step: ![](https://github.com/zed95/ROCO222-Journal/blob/master/Images/Double%20Step.gif)

```C
#define DIR_A 12
#define PWM_A 3
#define DIR_B 13
#define PWM_B 11
const int delayMs = 5;
unsigned char A_PWM = 0;
unsigned char B_PWM = 255;

void Double_step(unsigned char State1, unsigned char State2)
{
analogWrite(PWM_A,255);                     // Ch. A on           Turn on coil pair A to allow the teeth to align with the middle of the coils
analogWrite(PWM_B,255);                     // Ch. B on           Turn on coil pair B to allow the teeth to align with the middle of the coils
                                                                //this allows the motor to spin by only changing the polarity of the magnets
                                                                
digitalWrite(DIR_A, State1);                  // Ch. A forward      Set the polarity of coils in A 
digitalWrite(DIR_B, State2);                   // Ch. B forward      Reverse the polarity in Coils B to allow the stepper motor to spin


delay(delayMs);

digitalWrite(DIR_A, State1);                  // Ch. A forward      Set the polarity of coils in A 
digitalWrite(DIR_B, State1);                  // Ch. B forward      Set the polarity of coils in B


delay(delayMs);

digitalWrite(DIR_A, State2);                   // Ch. A backwards    Reverse the polarity in Coils A to allow the stepper motor to spin 
digitalWrite(DIR_B, State1);                  // Ch. B backwards    set the polarity in Coils B 

delay(delayMs);

digitalWrite(DIR_A, State2);                   // Ch. A forward      Reverse the polarity in Coils A to allow the stepper motor to spin 
digitalWrite(DIR_B, State2);                   // Ch. B forward      Reverse the polarity in Coils B to allow the stepper motor to spin


delay(delayMs);
 
}


void setup() 
{
pinMode(DIR_A, OUTPUT);
pinMode(DIR_B, OUTPUT);
pinMode(9, OUTPUT); digitalWrite(8, LOW);           //No braking ch. A
pinMode(8, OUTPUT); digitalWrite(8, LOW);           //No braking ch. B
}

void loop()
{
Double_step(LOW, HIGH);
}
```

Half-step: ![](https://github.com/zed95/ROCO222-Journal/blob/master/Images/Half%20Step.gif)

```C
#define DIR_A 12
#define PWM_A 3
#define DIR_B 13
#define PWM_B 11
const int delayMs = 5;
unsigned char A_PWM = 0;
unsigned char B_PWM = 255;

void Half_step(unsigned char PWM_1, unsigned char PWM_2)
{

digitalWrite(DIR_A, HIGH);                  // Ch. A forward      Set the polarity of coils in A 
digitalWrite(DIR_B, HIGH);                  // Ch. B forward      Set the polarity of coils in B

analogWrite(PWM_A,PWM_1);                     // Ch. A on           Turn on coil pair A to rotate the motor until teeth are aligned with coil pair A
analogWrite(PWM_B,PWM_2);                       // Ch. B off          Turn off coil pair B to allow the teeth to align with A

delay(delayMs);

analogWrite(PWM_A,PWM_2);                     // Ch. A on           Turn on coil pair A to allow the teeth to align with the middle of the coils 
analogWrite(PWM_B,PWM_2);                     // Ch. B on           Turn on coil pair B to allow the teeth to align with the middle of the coils

delay(delayMs);

analogWrite(PWM_A,PWM_2);                       // Ch. A off          Turn off coil pair A to allow the teeth to align with B
analogWrite(PWM_B,PWM_1);                     // Ch. B on           Turn on coil pair B to rotate the motor until teeth are aligned with coil pair B

delay(delayMs);

digitalWrite(DIR_A, LOW);                   // Ch. A backward     Reverse the polarity in Coils A to allow the stepper motor to spin 
digitalWrite(DIR_B, HIGH);                  // Ch. B forward      Set the polarity of coils in B

delay(delayMs);

analogWrite(PWM_A,PWM_2);                     // Ch. A on           Turn on coil pair A to allow the teeth to align with the middle of the coils
analogWrite(PWM_B,PWM_2);                     // Ch. B on           Turn on coil pair B to allow the teeth to align with the middle of the coils

delay(delayMs);

analogWrite(PWM_A,PWM_1);                     // Ch. A on           Turn on coil pair A to rotate the motor until teeth are aligned with coil pair A
analogWrite(PWM_B,PWM_2);                       // Ch. B off          Turn off coil pair B to allow the teeth to align with A

delay(delayMs);

digitalWrite(DIR_A, LOW);                   // Ch. A backwards    Reverse the polarity in Coils A to allow the stepper motor to spin 
digitalWrite(DIR_B, LOW);                   // Ch. B backwards    Reverse the polarity in Coils B to allow the stepper motor to spin 

delay(delayMs);

analogWrite(PWM_A,PWM_2);                     // Ch. A on           Turn on coil pair A to allow the teeth to align with the middle of the coils
analogWrite(PWM_B,PWM_2);                     // Ch. B on           Turn on coil pair B to allow the teeth to align with the middle of the coils

delay(delayMs);

analogWrite(PWM_A,PWM_2);                       // Ch. A off          Turn off coil pair A to allow the teeth to align with B
analogWrite(PWM_B,PWM_1);                     // Ch. B on           Turn on coil pair B to rotate the motor until teeth are aligned with coil pair B

delay(delayMs);

digitalWrite(DIR_A, HIGH);                 // Ch. A forward      Set the polarity of coils in A 
digitalWrite(DIR_B, LOW);                  // Ch. B forward      Reverse the polarity in Coils B to allow the stepper motor to spin

delay(delayMs);

analogWrite(PWM_A,PWM_2);                     // Ch. A on           Turn on coil pair A to allow the teeth to align with the middle of the coils
analogWrite(PWM_B,PWM_2);                     // Ch. B off          Turn on coil pair B

delay(delayMs);
}

void setup() 
{
pinMode(DIR_A, OUTPUT);
pinMode(DIR_B, OUTPUT);
pinMode(9, OUTPUT); digitalWrite(8, LOW);           //No braking ch. A
pinMode(8, OUTPUT); digitalWrite(8, LOW);           //No braking ch. B
}

void loop()
{
Half_step(A_PWM, B_PWM);
}
```

Micro-step:

```C
int microsteps = 200;            //Complete one step in 200 steps
float amp = 255;                 //Max PWM
int pulseDelay = 10000;             //the delay determines how fast the next set of information is going to be sent to the motor shield
int a[200];                      //Array to store PWM with sine pattern over 200 steps
int b[200];                      //Array to store PWM with cos pattern over 200 steps
int idxG;                        //Array pointer

void setup() 
{
  int idx;

  idxG = 0;                       //Initialise the array pointer

  for(idx = 0; idx < microsteps; idx++)
    {
      a[idx] = amp * sin(idx * 2 * PI / microsteps);      //populate the array with PWM values following sine pattern over 200 steps
      b[idx] = amp * cos(idx * 2 * PI / microsteps);      //populate the array with PWM values following cos pattern over 200 steps
    }

  //configure the motor shield pins 
  pinMode(12,OUTPUT);
  pinMode(13,OUTPUT);
  pinMode(9,OUTPUT);
  pinMode(8,OUTPUT);

  //Disable the breaks 
  digitalWrite(8, LOW);
  digitalWrite(9, LOW);

}

void WriteValue(int value, int chanAnalog, int chanDigit)
{

  int vaueAbs = abs(value);             //Get the absolute value. if value = -200 then vaueAbs  = 200
  analogWrite(chanAnalog, value);       //update the motor shield witht he new PWM value
  if(value > 0)                         //The polarity of the coils is changed once the values go below zero and vice versa
    {
      digitalWrite(chanDigit, LOW);
    }
  else
    {
      digitalWrite(chanDigit, HIGH);
    }
}

void loop() {

  //send values the the function to be processed and then sent to the motor shield
  WriteValue(a[idxG], 3, 12);
  WriteValue(b[idxG], 11, 13);

  idxG++;                         //Increment idxG to get the next values from the two arrays

  if(idxG == microsteps)          //once the last values in the arrays have been processed and sent, reset idxG to repeat
  {
    idxG = 0;
  }
  delayMicroseconds(pulseDelay);  //delay the program before continuing to allow the changes to be implemented in the stepper motor
}
```

After uploading the micro-step code to the arduino the motor's operation was smoother. We could tell by it vibrating as much as it did in other modes of operation.



## Characterisation

To estimate the maximum angular velocity of the different mode me and Kyle set the delay to a value that made the motor look like it is rotating and its fastest. We then used a stopwatch record the time it took the stepper motor to complete one revolution in the different modes. The procedure was repeated 5 times for each of the modes and then an average angular velocity was calculated for the different modes. The results for maximum angular velocity are shown below:

|Micro-step    |
|--------------|
|Attempt|Time  |
|-------|:----:|
|1	|  1.09|
|2	|  1.13|
|3	|  1.09|
|4	|  1.01|
|5	|  1.03|
|Average|  1.07|

Angular Velocity = 360/1.07 = 336.5 deg/s

|Full-step     |
|--------------|
|Attempt|Time  |
|-------|:----:|
|1	| 1.03 |
|2	| 1.03 |
|3	| 0.98 | 
|4	| 0.99 |
|5	| 0.95 |
|Average| 0.996|

Angular Velocity = 360/0.996 = 361.5 deg/s

|Double-step   |
|--------------|
|Attempt|Time  |
|-------|:----:|
|1	|  1.01|
|2	|  0.98|
|3	|  0.96|
|4	|  0.96|
|5	|  0.99|
|Average|  0.98|

Angular Velocity = 360/0.98 = 367.4 deg/s

|Half-step     |
|--------------|
|Attempt|Time  |
|-------|:----:|
|1	|  1.80|
|2	|  1.88|
|3	|  1.73|
|4	|  1.75|
|5	|  1.74|
|Average|  1.78|

Angular Velocity = 360/1.78 = 202.3 deg/s


Motor torque in different modes from strongest to weakest. What we did to decide one the order is we held the shaft to see what resistance each of the modes gives. The Half-step and the Micro-step were very similar in terms of torque but Half-step was just a little stronger than the Micro-step mode.

1 Double-step
2 full-step
3 Half-step
4 Micro-step


6 - Servo control (27/11/2017)
============================================

## How servo works
The servo contains circuitry which compares the the position of the servo to the commanded position by the user. When the difference between the two is not zero, the motor in the servo is powered to move in the appropriate so that the difference can be reduced to zero again.

![](https://github.com/zed95/ROCO222-Journal/blob/master/Images/Servo%20Diagram.png)


## Controlling the RC servo
In the SG90 datasheet three commands are given to set the positon of the servo: 0deg = 1.5ms pulse, 90deg = 2ms pulse, -90deg = 1ms pulse. Using these thhree commands I will be able to make the servo move over its entire range of motion which is 180 degrees. The datasheet also states that the period of the pulse is 20ms for which the the time that the pulse is HIGH is either 1ms, 1.5ms or 2ms based on which command I will be sending to the servo. The written program is shown below:

```C

int PWMpin9 = 9;                                        //The PWM wire of the servo motor will be connected to pin 9 of the Arduino as it is a pwm pin.

void setup() {
  // put your setup code here, to run once:
pinMode(PWMpin9, OUTPUT);                               //Set the PWM pin 9 to output.
}

void setPos(int pulseWidth){

  digitalWrite(PWMpin9, HIGH);
  delayMicroseconds(pulseWidth);                      //Time for which the puls is HIGH
  digitalWrite(PWMpin9, LOW);
  delayMicroseconds(20000 - pulseWidth);              //time for which the pulse is LOW
}


void loop() {
  
setPos(500);                                        //Send time period for which the pulse will be HIGH.
delay(200);                                         //delay the transmission of next command to allow time for the mechanical part of the servo to move to specified position

setPos(1500);
delay(200);

setPos(2500);
delay(200);

setPos(1500);
delay(200);

 //The values in the datasheet were only suggested values by the manufacturer. After trying threm our servo did not want to rotate 180 degrees. 
 //We have increased and decreased the pulse widths using trial and error method to finally find values that allow our servo to rotate 180 degrees.
} 
```

180 degrees rotation: ![](https://github.com/zed95/ROCO222-Journal/blob/master/Images/Servo_rotation.gif)

## Controlling servo with potentiometer
I used servo library to helo me control the servo with the potentiometer. The code is shown below:

```C
#include <Servo.h>

Servo myservo;  // create servo object to control a servo

int potpin = 0;  // analog pin used to connect the potentiometer
int val;    // variable to read the value from the analog pin

void setup() {
  myservo.attach(9);  // attaches the servo on pin 9 to the servo object
  Serial.begin(9600); // initialises serial communication at baud rate of 9600
}

void loop() {
  val = analogRead(potpin);            // reads the value of the potentiometer (value between 0 and 1023)
  Serial.println(val);                 // prints the value of the potentiometer to the serial monitor
  val = map(val, 0, 1023, 0, 180);     // scale it to use it with the servo (value between 0 and 180)
  myservo.write(val);                  // sets the servo position according to the scaled value
  delay(15);                           // waits for the servo to get there
}
```
controlling the servo: ![](https://github.com/zed95/ROCO222-Journal/blob/master/Images/Servo_rotation.gif)

## Robot arm mock-up
To estimate the torque of the motor, I have measured and marked distance from the center of the motor in 1cm intervals. I have also created a weight from 14, 2p coins to create a mass of 102g. The equation for torque is: &#964 = F&#215d. This equation assumes that the force acts 90 degrees with respect to the center of the sha servo shaft and so I will make sure that when I test the torque, the weight will be perpendicular to the shaft. The equation is tellig me that the force on the servo shaft will increase with distance. from the datasheet of the servo I get that the stall torque is 1.8kgf*cm, this tells me that If I approximate my weight to be 100g, the servo should stall when the weight is attached 18cm from the servo shaft (1.8 &#215; 1 = 0.1 &#215; 18).

After testing the torque of the servo motor I have obtained the stall torque to be 1.7kgf*cm. This result is close enough to the given value in the datasheet and therefore I will conclude that the experiment was performed correctly. 

The weight: ![](https://github.com/zed95/ROCO222-Journal/blob/master/Images/weight.jpeg)

The arm: ![](https://github.com/zed95/ROCO222-Journal/blob/master/Images/Measuring%20torque.jpeg)

## Add second servo and write program to control both servos
To write the program I copied the previous program but added more code to initialise the pins for the second servo. The code is shown below:

```C
#include <Servo.h>

Servo myservo;  // create servo object to control a servo
Servo myservo2;

int potpin = 0;  // analog pin used to connect the potentiometer
int potpin2 = 1;
int val, val2;    // variable to read the value from the analog pin

void setup() {
  myservo.attach(9);  // attaches the servo on pin 9 to the servo object
  myservo2.attach(10);  // attaches the servo on pin 10 to the servo object
  Serial.begin(9600); // initialises serial communication at baud rate of 9600
}

void loop() {
  val = analogRead(potpin);            // reads the value of the potentiometer (value between 0 and 1023)
  Serial.println(val);                 // prints the value of the potentiometer to the serial monitor
  val = map(val, 0, 1023, 0, 180);     // scale it to use it with the servo (value between 0 and 180)
  myservo.write(val);                  // sets the servo position according to the scaled value
  delay(15);                           // waits for the servo to get there

 val2 = analogRead(potpin2);            // reads the value of the potentiometer (value between 0 and 1023)
  Serial.println(val2);                 // prints the value of the potentiometer to the serial monitor
  val2 = map(val2, 0, 1023, 0, 180);     // scale it to use it with the servo (value between 0 and 180)
  myservo2.write(val2);                  // sets the servo position according to the scaled value
  delay(15);                           // waits for the servo to get there
}
```

Two servos being controlled: ![](https://github.com/zed95/ROCO222-Journal/blob/master/Images/Controlling_servos.gif)

## Designing a better robotic arm
I have decided to design my own robotic arm inspired by one of the pictures in the roco labs. I have designed the parts myself and had to measure the dimensions of the sg90 servo motor so that it fits into the skeleton. I had to make the mounting space bigger than the actual servo so that the servo can fit into the skeleton. The links to the designs are listed below.

[Part 1](https://github.com/zed95/ROCO222-Journal/blob/master/3Dprints/Robot%20Arm%20Part1.stl)

[Part 2](https://github.com/zed95/ROCO222-Journal/blob/master/3Dprints/Robot%20Arm%20Part2.stl)

[Part 3](https://github.com/zed95/ROCO222-Journal/blob/master/3Dprints/Robot%20Arm%20part3.stl) - a nut to ensure the parts remain attached together

[Part 4](https://github.com/zed95/ROCO222-Journal/blob/master/3Dprints/Robot%20Arm%20part4.stl)

[Part 5](https://github.com/zed95/ROCO222-Journal/blob/master/3Dprints/Robot%20Arm%20part5.stl)

The assembly required me to sand the sides of the mounts to make them bigger so that the servos fit because the prints were printed a bit smaller than expected. In the end I managed to assemble everything together. The pictures from the assembly process are shown below.

![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/Robot%20arm%20assembly%20beginning.jpeg)
Servos now fit nicely after mount sanding.

![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/Robot%20arm%20Assembly.jpeg)
The parts attached so well together that I did not need to nuts to keep the skeleton together!

![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/Robot%20arm%20assembly%20finish.jpeg)
The Assembled robot arm. I was short on 1 servo as I destroyed it by accident during testing in the other lab.

![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/Use%20pots%20to%20control%20arm.jpeg)
I used the code written to control the two potentiometers and tested the arm to see if the arm functional. I can conclude that the dsign was successful. 




