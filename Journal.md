2 - Build a DC motor (02/10/2017)
==================================

## Building the commutator
 
The **commutator** is responsible for reversing the current through the coil when that coil moves through the magnetic field to ensure constant rotation of the motor. A basic commutator is simply two metal plates which will come in contact with positive and negative wires of the power supply while rotationg.
 
The first step me and my lab partner Kyle have taken to contruct the commutator was sticking the copper tape around one side the cork.
 
![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/IMG_0486.JPG)
 
Before dividing the copper into two plates, I have decided to first draw a line on the cork to indiciate where we should make the divide. The point of this was to make sure that the lengths of the two plates are approximately the same length.
 
![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/IMG_0487.JPG)
 
![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/IMG_0488.JPG)


## Adding the support shaft
 
The support shaft is usually a metal rod on which the **armature** rests on and spins around its axis. The support shaft we will be using is made up if two metal pins.
 
There wasn't much to do in this section, the two pins only needed to be pushed into the middle of the cork from both sides create the shaft.
 
![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/IMG_0489.JPG)

## Winding the armature coil
 
The **armature coil** generates a megnetic field when current is passed through it. Combined with magnets, attractive and repulsive forces are generated which make the coil rotate. The coil is created by winding the copper wire around an object.
 
Before me and Kyle started winding the copper wire around the cork, we made sure that one end of the wire is sticking out so that it can then be attached to one of the sides of the commutator to allow current to pass through the coil.
 
Winding the wire around the cork wasn't easy as the copper wire kept getting tangled, which then had to be untangled which in turn took time and effort. In addition to that, we had to be careful to not damage the commutator in any way. After achieving **150 turns** of wire around the cork, we have sucuessfully created the coil. We have measured the total resistance of the coil using a multimeter; the measured value was **7.5&#937;**. We made sure that there was enough wire to attach the other end to the other part of the commutator.To secure the coil, we have taped it to the cork using electrical tape. The two ends of the wire had to be sanded down to remove the enamel on the copper which prevented the it wire from conducting electricity. At the end, I soldered the wires to the commutator.
 
![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/IMG_0491.JPG)
 
![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/IMG_0492.JPG)


## Building magnet brackets and shaft support
 
The **shaft support** is where the shaft is going to rest. The purpose of the shaft support is to susped the armature with the coil in the air so that nothing stops it from spinning.The purpose of the magnet is to provide a magnetic field for the motor's magnetic field to interact with and produce torque. We have been provided with large paperclips to produce the shaft support and magnet brackets.
 
To create the shaft support we have taken two steps. The first step was to bend the paperclip so that it formed a 90&#176; bracket. The second step was to bend the vertical end of the paperclip out and then create a loop for the shaft to fit in. To create the magnet brackets we just followed the first step.


## Building the baseplate
 
We have been provided with a baseplate, screws and washers to attach everything onto the baseplate. We have marked the baseplate wih two lines perpendicular to each other so that we could align the parts correctly. We have then aligned the paperclips and attached them to the baseplate using the screws and washers. Next, we have placed the DC motor on the shaft support and then atached the neodymium magnets onto the magnet brackets, at the same height as the coil. The magnets came together several times during this process and due to neodymium magnet strength, trying to separate them became bothersome. We have learned that we should be more careful when handling neodymium mangnets.
 
![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/IMG_0493.JPG)


## Finishing the motor
 
Once me and Kyle attached everything to the baseplate, We created brushes from copper wire. The brushes supply power to the coil so that it can produce torque. We have connected supply leads to the copper wires and adjusted the voltage to 12V and set the current limit to 2A as advised.
 
![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/IMG_0494.JPG)


 ## Testing the motor
 
After switching on the supply, the coil twitched, but did not rotate. I suspect that it was due to the fact that the commutator was not smooth and circular enough in shape to continously conduct current well. I did not have enough time to improve the shape of the commutator and test it and so that will be the first thing I do during the next practical.


2 - Build a DC motor (09/10/2017)
==================================

 ## Testing the motor
 
 As suspected last week, The problem with the motor twitching but not actually rotating was the commutator shape. The commutator needed to be more round (it became deformed when winding the wire to create the coil). After forming the commutator to have a more round shape, the motor started spinning without any problems.
 
 To make sure that the connection is constant between the coil and the power supply during the spinning of the motor, I have folded the bursh wires. I have done this because during the motor operation the brushes moved and sometimes lost contact with the crocodile clips of the power supply. 
 
![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/Improved%20Commutator%20shape.JPG)
 
![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/Folded%20brush%20wires.JPG)


2 - Build a DC motor (nn/10/2017)
=================================

 ## Testing the motor
 
 **Measure rotational speed using modulation in armature current** Ask Severin about this one
 
 **How fast does the motor rotate at a given applied voltage** Use movie maker or some other program to slow down the video recorded and count the number of rotations the motor has completed in a given time interval to work out the speed.
 
 **Plot current as a function of voltage**


2 - Build a DC motor (12/10/2017)
=================================

 ## A better DC motor

 I have originally decided that I am going to make a 6 coil motor with some iron inside the armature to increase the magnetic field strength. After ordering iron washers, I realised that the armature would have to be much larger to accomodate the washers in all 6 of the armature teeth, since the washers were 3/4" in outer diameter. To keep the armature approximately the same size as the one I designed previously designed, I decided to stick with 3 coils. Having only 3 coils in the design made the design only a little bigger, with the original design having dimensions of 50x50x75mm and the new design having dimensions of 68x68x75mm to accommodate the iron washers. The new design is based on the old design of the armature which I created several months ago as a part of my personal project. Because I will have iron washers inside of my coils, the DC motor will be subject to **cogging**. To reduce the effects of cogging I have rotated the armature teeth by 6&#176;.
 
![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/Old%20Armature.png)
A picture of the old armature design
 
[For 3D view of new armature design click here](https://github.com/zed95/ROCO222-Journal/blob/master/3Dprints/ROCO222%20Armature.stl)
A picture of the new armature design
 
When the new armature finished printing, I placed the iron washers inside the armature teeth. I managed to fit 20 washers in each tooth which added weight to the print. To make sure that they do not fall out (I had to make the holes bigger than the washers actually are to make up for the fact that 3D printers are not 100% accurate and might not print the desired hole size), I used tape the secure them in place.
 
 My next step was to start winding the copper wire around the armature teeth to create coils. I wanted to have 1000 turns on each but settled at 800 turns on each tooth as the coils would become too big to fit around the armature. I kept a tally so that I don't forget how many turns I have done on a particular tooth. I would add one to the tally every 100 turns. To make sure that the coil does not unwind during the winding process, I applied super glue every 300 turns and after finishing winding a tooth. The DC motor is wave wound.

![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/New%20armature%20showing%20washers.JPG)
A picture of the new armature design with the washers fitted.
 
![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/New%20armature%20with%20coils.JPG)
A picture of the new armature with coil windings.
 
![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/Turns%20tally.png)
A picture of the turns tally.
 
I have also attached a shaft to the armature (as seen in the picture above) to allow the DC motor to spin when it is powered. The shaft is longer on one side and shorter on the other, the reason being that I will have to attach an encoder on the longer side of the shaft.


2 - Build a DC motor (16/10/2017)
==================================

## A better DC motor

Today I added copper to the commutator and soldered the wires of the coils onto it. I then tested the DC motor to see how it performs. The magnetic field was very strong compared to the previous DC motor me and Kyle made, however, it was difficult to start the motor due to the support not being able to hold motor and the magnet holders not being able to hold the strong neodymium magnets in place.
 
 Upon arriving home, I began to design the new, improved motor support and magnet holders. I designed DC motor support to be triangular in shape so that if the motor starts vibrating the whole structure is more stable overall. intending to screw the support into the wood, I made holes for the screws in the support. The benefit of doing it this way over glueing the support to the wood is that I can always unscrew the support and adjust it if it needs re-aligning.
 
 To save on the cost of printing the DC motor support, I changed the shape of the supoport by removing sections of the support that are unnecessary. Removing the unecessary parts left the support looking like a trapezium and reduced the cost by £1.74 per support.
 
[For 3D view of motor support click here](https://github.com/zed95/ROCO222-Journal/blob/master/3Dprints/Shaft%20support.stl)
 
 After finishing the motor support design, I moved onto the magnet holders design. Designing the holders was more complicated compared to the motor support because I needd to make sure that the magnets will be in line with motor. I drew a diagram to help me with working out how high the magnet holders need to be and where the magnets needs to be positioned to be in level with the motor. I have made the thickness of the holders 10mm so that they are durable. Originally, I made openings at the back so that the magnets could be inserted into the holders but changed my mind and re-designed the holders to have the openings for the magnets on top; this way they are less likely to fall out of the holders. I have also made holes for screws in the magnet holders for the same reason mentioned in designing the motor support. Similarly, I also removed unnecessary material from the magnet holders to reduce the cost of printing and saved £2 per magnet holder.
 
![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/Magnet%20holder%20dimenions.png)
 A picture of the diagram used to work out the required height of the magnet holders.
 
[For 3D view of magnet holder click here](https://github.com/zed95/ROCO222-Journal/blob/master/3Dprints/Magnet%20holders.stl)


3 - Incremental encoder (16/10/2017)
======================================

## Building the incremental encoder
 
The phototransistor switches on when the IR light shines onto it.
 
We have been provided with a circuit diagram according to which we must construct the encoder. Making the IR light source and the light detector wasnt hard, we just needed to solder the two onto the verboard. We have then moved onto testing the circuit. While testing I realised that I soldered the positive pin of the phototransistor to the negative pin of the LED and I wasnt getting any results. After I corrected the mistake, I tested the circuit again and everything was working as intended; we had a voltage drop when we covered the LED so that the IR light didnt reach the phototransistor and we could see the IR light from the LED when we took a photo using the phone.
 
![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/Encoder%20circuit%20diagram.png)
Picture of the encoder circuit provided.
 
![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/original%20circuit.jpeg)
A picture of our encoder circuit.
 
![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/IR%20light.jpg)
Picture of the IR light being emitted.
 
![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/IR.jpeg)
A picture of voltage level when the IR light is allowed to shine onto the phototransistor.

![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/IRblocked.jpeg)
A picture of the voltage level when the IR lights is blocked from the phototransistor.
 
While testing we have been told that we will need the LED and phototransistor to be higher up relative to the verobard so that the rotating disc that we will use to block the IR light can block the light properly; otherwise the voltage drop may not be significant enough and our encoder will not work as intended. I will make the necessary adjustments with Kyle in the next practical.

3 - Incremental encoder (23/10/2017)
==========================================================

We have made the necessary adjustments to the positioning of our components on the breadboard and our circuit was ready to be used. After adding the encoder disc, we were ready to estimante the speed of rotation of our motor.

![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/Adjusted%20circuit.jpeg)
A picture of the adjusted encoder circuit.

![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/Encoder%20disc.jpeg)
A picture of the encoder disc

## Estimating rotation speed in RPM
How it works is we should get a square wave as the motor rotates because the disc allows the light to reach the phototransistor and then blocks the IR light so it doesnt get to the transistor. When the light shines onto the phototransistor the voltage goes to 5V and when it is blocked it goes to 0V and so a square wave between 0V and 5V will be produced at a frequency which is determined by the speed of rotation the motor. Obtaining the frequency will allow me and kyle to calculate speed of rotation. Frequency is measured per second and each cycle corresponds to one revolution then multiplying the frequency by 60 we should get rotations per minute.

**perform this experiment, take pictures of the serup, record the frequency and perform calculations on the result the get the estimated RPM**

plug the encoder to the oscilloscope and run the motor and I should get a square wave as the light is blocked and unblocked. Because of the square wave I can get a frequency reading from the oscilloscope from which I can determine the rotations per minute (RPM). take picture of the square wave and the frequency and do any calculations needed as evidence of recorded rotation speed of motor 



## Calculating Angular velocity of the motor
Me and kyle have written the code to display the pulse count on the serial monitor in the Arduino IDE. After uploading the program to the arduino we have decided to see if we can calculate the angular velocity of our motor. The code is shown below.

```C
const byte ledPin = 13;
const byte interruptPin = 2;
volatile byte state = LOW;
unsigned int PulseCounter = 0;                                                  //Store the pulse count here
unsigned int TimePoint1 = 0, TimePoint2 = 0;                                    //Time at the start of the loop will be stored in TimePoint1 and time at the end of the loop will be stored in TimePoint2





void AngularVelocity() {                                                      // Right now I assume that I have one hole which calculates me the revolutions per second but we will do calculations for getting the angular velocity
TimePoint1 = millis();                                                        //Store current time since begninning of the program
  Serial.println(PulseCounter);                                               //Display the pulse count on the serial monitor
  PulseCounter = 0;                                                           //Reset the pulse counter
}



void setup() {
 Serial.begin(9600);                                                            //Initialise serial communication at 9600 bits per second
pinMode(ledPin, OUTPUT);
pinMode(interruptPin, INPUT);
// configure the interrupt call-back: blink is called everytime the pin
// goes from low to high.
attachInterrupt(digitalPinToInterrupt(interruptPin), blink, RISING);
TimePoint1 = millis();                                                        //Store current time since begninning of the program
}
void loop() {
digitalWrite(ledPin, state);
TimePoint2 = millis();                                                        //Store current time since begninning of the program

if(TimePoint2 - TimePoint1 >= 1000) {                                         //If the difference between the two time points is more or equal to 1000ms (1 second)
    AngularVelocity();                                                        //Run the Angular velocity function
}
}
void blink() {
state = !state;
PulseCounter ++;                                                            //Increment the counter
}
```

Result:
![alt text](<iframe src="https://giphy.com/embed/3ohjUNLA7H569UK4Ba" width="270" height="480" frameBorder="0" class="giphy-embed" allowFullScreen></iframe><p><a href="https://giphy.com/gifs/encoder-3ohjUNLA7H569UK4Ba">via GIPHY</a></p>)

Afer having several attempts we have come to the conclusion that something is going wrong in recording the angular velocity of our motor. We have plotted graphs with our results and the readings were looking very inconsistent and some of them even ridiculous like 1000 revolutions per second which would correspond to a angular velocity of 360,000 degrees per second. For comparison, We have measured the angular of my drill; although the recordings varied less than in our motor, the results were still inconsistent with the velocity being 14,400 degrees per second on average and then suddenly rocketing to around 28,800 or diving to around 3,600 in matter of a second bearing in mind that the drill has a profesionally designed motor compared to our crude design. Because of this my conclusion for today is that the problem lies somewhere in the encoder disc or the circuit. I will look into it tomorrow and try to figure out what the problem is.

![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/Angular%20v%20A1.png)
A picture of angular velocity graph of the motor x-axis = time in seconds and y-axis is pulses per second.

![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/Angular%20v%20A2.png)
A picture of angular velocity graph of the motor x-axis = time in seconds and y-axis is pulses per second.

![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/Angular%20v%20A3.png)
A picture of angular velocity graph of the motor x-axis = time in seconds and y-axis is pulses per second.

![alt text](https://github.com/zed95/ROCO222-Journal/blob/master/Images/Drill%20angular%20velocity%20readings.png)
A picture of angular velocity graph of the drill. x-axis = time in seconds and y-axis is pulses per second.
 
3 - Incremental encoder (24/10/2017)
==========================================================

upload the video of the encoder making the LED blink after the program has been uploaded to the Arduino. Upload the code of my ptogram which is used to calculate angular velocity by counting pulses. show any calculations necessary for calculating angular velocity from the pulse counter in the program. show the excel results and graphs that we have obtained from the program and explain the weird results that we got which might be due to the way we did the whole experiment or the design of motor or the encoder or the program itself not being perfect and compare agains the results that we got from spinning the drill and recording the pulses .


## Improving the resolution of the encoder
what I can do to improve the resolution of my encoder is instead of measuring the pulses per second I can measure the time difference between the pulses to get the angular velocity. How this would work is I would record time for one pulse and then the time for the other pulse. I would then subtract pulse time one from pulse time to to get the time difference between the two. I know that a time difference of 1 second would correspond to one revolution per second (or 360 degrees per second). Similarly, a time difference of 2 seconds would correspond to a angular velocity of 180 degrees per second since it took two seconds for a full revolution. Again, if the time between the pulses is 500ms, this would correspond to angular velocity of 720 degrees per second since a full revolution took only half a second.

If I have time I will update the code to do just that.



